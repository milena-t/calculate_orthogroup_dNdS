#  the script takes an orthogroup fasta file generated by orthofinder as input. The original script 
#  would generate this file from a csv list, but since it is already generated by orthofinder
#  I will skip this step and go immediately to the alignment.

#  The original script offers different alignment software options, but I will only implement clustal-OMEGA.

##	INPUT
#	(+)An orthogroup multifasta file generated by orthofinder. (only use orthogroups exclusively
#       consisting of 1-to-1 orthologs!)
#	(+)Corresponding DNA and Protein sequences for each ortholog, in FASTA format. 
#       If a directory is given then the script will assume it contains complete cds fastas and extract the required sequences by sequence header itself

##	OUTPUT
#	Up to four files will be generated for each desired ID:
#	(+)<orthogroup_ID>.fa_extracted_cds.fna	| A multiple-sequence FASTA file of the Nucleotide orthologs. Not aligned.
#	(+)orthogroup.prot_aln.fasta			| An alignment file of the protein orthologs, FASTA format.
#	(+)orthogroup.pal2nal.paml		    	| A codon-based nucleotide ortholog alignment, for use with PAML
#	(+)[2YN|2NG].dNdS   	    	    	| pairwise dN/dS values calculated by yn00 or codeml respectively

##  REQUIREMENTS:
#   (+) stuff on uppmax:
#       module load bioinfo-tools clustalo/1.2.4 biopython/1.80-py3.10.8 paml/4.10.7
#       (+) BioPython       | (The original script uses BioPerl since it's in perl), can be loaded as uppmax module
#       (+) CLUSTAL-Omega   | (For multiple-sequence alignments), can be loaded as uppmax module
#       (+) PAML            | can be loaded as uppmax module
#   (+) stuff not on uppmax:
#       (+) pal2nal         | (not available on uppmax, get from github and set binary path with command line flag)
#                           | /proj/naiss2023-6-65/Lila/beetle_genomes/pal2nal.v14/pal2nal.pl

#	For USAGE please run without any options or specifying flag -h or --help


##  TESTING:
#   test case: 1-to-1 orthogroup
#       /proj/naiss2023-6-65/Lila/beetle_genomes/Orthofinder_beetles/OrthoFinder/Results_May30/Orthogroup_Sequences/OG0006976.fa
#   species cds directory
#       /proj/naiss2023-6-65/Milena/gene_family_analysis/cds_native_annotations
#   command
#       python3 calculate_orthogroup_dNdS.py --orthogroup /proj/naiss2023-6-65/Lila/beetle_genomes/Orthofinder_beetles/OrthoFinder/Results_May30/Orthogroup_Sequences/OG0006980.fa --cds /proj/naiss2023-6-65/Milena/gene_family_analysis/cds_native_annotations --pal2nalbin /proj/naiss2023-6-65/Lila/beetle_genomes/pal2nal.v14/pal2nal.pl --verbose --overwrite




import argparse
from Bio import SeqIO, AlignIO
import os
import subprocess
import re
import time


def parse_args():
    # Create the parser
    program_description = """
A script to calculate the dN/dS ratio for an input orthogroup.
The individual steps consist of:
(1) make a cds fasta using the input proteinfasta as a template, if no cds fasta is given
(2) make a codon-based multi-sequence alignment 
(3) run yn00 and calculate the pairwise dNdS ratio
"""
    parser = argparse.ArgumentParser(description=program_description)

    # Add the arguments
    parser.add_argument('-f', '--orthogroup', type=str, required=True, help='Absolute filepath to the protein multifasta file of the orthogroup of interest')
    parser.add_argument('--cds', required=True, help="coding sequence (aminoacid) multifasta corresponding to the orthogroup proteinfasta or a directory containing the complete cds fasta for all species so that the program can extract the nucleotide sequences automatically")
    parser.add_argument('-o', '--outdir', type=str, help='Directory where the output_file is stored, default: filename from orthogroup input')
    parser.add_argument('--pal2nalbin', type=str, help="Absolute path to an executeable to run pal2nal, default: ./pal2nal.pl")
    parser.add_argument('--pal2naloptions', type=str, help="command line options for pal2nal, default: -output paml -nogap -nomismatch")
    parser.add_argument('--clustalbin', type=str, help="path to the clustal-omega executeable if it is not default clustalo. not necessary if the uppmax module is loaded with: module load clustalo/1.2.4")
    parser.add_argument('--alnoptions', type=str, help="optional alignment options, empty by default")
    parser.add_argument('--codeml', action='store_true', help="run codeml instead of yn00 by default. codeml takes a few minutes and yn00 only a few seconds")
    parser.add_argument('--verbose', action='store_true', help="enable verbose mode")
    parser.add_argument('--overwrite', action='store_true', help="overwrite existing output files with default names from previous runs")

    # Parse the arguments
    args = parser.parse_args()

    # set default values for non-obligatory arguments
    if not args.outdir:
        args.outdir = args.orthogroup.split("/")[-1].split(".")[0]+"_dNdS"
        # print(f"no output directory provided, default directory created: {args.outdir}")
    if not args.pal2nalbin:
        args.pal2nalbin = "./pal2nal.pl" # assumes pal2nal is in the current directory
    if not args.pal2naloptions:
        args.pal2naloptions = "-output clustal -nogap -nomismatch" # Originally: -output clustal -nogap -nomismatch"  
    if not args.alnoptions:
        args.alnoptions = ""
    if not args.clustalbin:
        args.clustalbin = "clustalo"
    if not args.pamlmodel:
        args.pamlmodel = "1"
    # if not args.verbose:
    #     args.verbose=False

    if args.cds[-1]!="/": # if cds is a directory and the user does not include a trailing "/", add it
        args.cds=args.cds+"/"
    
    if args.outdir[-1]!="/": # if outdir does not include a trailing "/", add it
        args.outdir=args.outdir+"/"

    return args




# Function to adjust spacing in the PHYLIP file
def adjust_phylip_spacing(input_file, output_file):
    new_lines = []
    with open(input_file, "r") as infile:
        lines = infile.readlines()
        for line in lines:
            if line.strip() and not line.startswith(" "):
                name = line[:10]
                sequence = line[10:]
                # outfile.write(f"{name:10}  {sequence}\n")
                new_lines.append(f"{name:10}  {sequence}\n")
            else:
                # outfile.write(line)
                new_lines.append(line)
    with open(output_file, "w") as outfile:
        outfile.writelines(new_lines)


# if the tree is needed, modify the leaf names to only be the first 10 characters to mach with the pal2nal alignment file
# the treefile also needs to be a tree structure file (see page 15 of the paml documentation)
# 
def truncate_leaf_names(newick_tree):
    # Regular expression to match leaf names
    pattern = re.compile(r'([a-zA-Z_@0-9.-]+):')

    def split_at_second_occurrence(s, char="_"): # split the gene string at the second occurence of "_" to get only the species name
        second_occurrence = s.find(char, 2) # start after the first occurence of "_"
        string = s[second_occurrence+1:]
        return string
    
    def truncate_match(match):
        leaf_name = match.group(1)
        leaf_name = split_at_second_occurrence(leaf_name) # split the first iteration of the species name that orthofiner adds (i think? no idea where else it would come from) to be sure that everything matches
        truncated_name = leaf_name[:10]
        return truncated_name + ':'
    
    # Substitute each leaf name with its truncated version
    modified_tree = pattern.sub(truncate_match, newick_tree)

    # get the number of species in the tree (number of matches to the pattern)
    num_species = len(list(pattern.finditer(newick_tree)))
    return modified_tree, num_species


def make_cds_fasta(proteinfasta, cds_list, verbose):

    nucleotide_fasta = []
    record_found = False

    print(f"generating CDS fasta file from {proteinfasta}")

    start_time = time.time()
    # go through all protein names in the proteinfasta
    for OG_record in SeqIO.parse(proteinfasta, "fasta"):
        record_found=False

        # remove the trailing "_1" that the orthofinder protein ID names have
        if OG_record.id[-2:] =="_1":
            OG_record.id = OG_record.id[:-2]
        if verbose:
                print(f"\tcurrently seqrching: {OG_record.id}")
    
        # find which protein header matches the current OG_record.id
        for species in cds_list:
            if verbose:
                species_print = species.split("/")[-1]
                print(f"\t\tcurrently reading: {species_print}")
            for species_cds in SeqIO.parse(species, "fasta"):

                # orthofinder replaces "|" with "_", so I have to replace it here too or I won't find matches 
                if "|" in species_cds.id:
                    header = species_cds.id
                    header = header.replace("|", "_")
                    species_cds.id = header

                # find matching species_cds.id in complete nucleotide cds files
                if species_cds.id in OG_record.id or OG_record.id in species_cds.id:
                    # print(species_cds.id)
                    species_cds.id = OG_record.id.split(" ")[0]
                    nucleotide_fasta.append(species_cds)
                    record_found=True
                    break # don't continue if a match is found. It seems like it works pretty well with the unique gene names, so breaking here to cut down on runtime instead of including a warning for double-matches seems worth it
            if record_found==True:
                if verbose:
                    print(f"\t\tfound! {species_cds.id}")
                break
                # break 
        if record_found==False:
            print(f'WARNING: no matching cds record found for protein record {OG_record.id} in orthogroup file {proteinfasta}.')
    
    end_time = time.time()
    passed_time = end_time - start_time
    if verbose:
        print(f"making the nucleotide fasta file took {passed_time:.2f} seconds, or {passed_time/60.0:.2f} minutes")
    return(nucleotide_fasta)



def is_file_non_empty(file_path):
    # Check if the file exists
    if os.path.isfile(file_path):
        # Get the size of the file
        if os.path.getsize(file_path) > 0:
            return True
    return False



def calculate_dNdS(dN_filepath, dS_filepath, dNdS_filepath):
    with open(dN_filepath, "r") as dN_file, open(dS_filepath, "r") as dS_file, open(dNdS_filepath, "w") as dNdS_file:
    
        dN_values = [dN_values.split() for dN_values in dN_file.readlines() if len(dN_values.split())>0][1:] # the if condition makes sure the line is not empty. Also cut out the first line that only contains the number of species
        dS_values = [dS_values.split() for dS_values in dS_file.readlines() if len(dS_values.split())>0][1:]
        
        if verbose:
            print(f"dN/dS values for {outdir_path}")
        for i in range(len(dN_values)): # loop through all subsequent lines
            
            species = dN_values[i][0]
            dN = [float(i) for i in dN_values[i][1:]]
            dS = [float(i) for i in dS_values[i][1:]]
            dN_dS_ratio_line = "\t".join([str(dN[j]/dS[j]) for j in range(len(dN))])
            dN_dS_ratio_line = "\t".join([species, dN_dS_ratio_line])

            if verbose:
                print(dN_dS_ratio_line)
            dNdS_file.write(dN_dS_ratio_line+"\n")

        if verbose:
            print(f"dN/dS values were written to file {outdir_path}{dNdS_filepath}")




if __name__ == '__main__':
    
    ### define variables from command line input

    args=parse_args()
    proteins_filename = args.orthogroup
    nucleotides_filename = "" # this is created below 
    outdir_path = args.outdir
    cds_path = args.cds
    clustal_bin = args.clustalbin
    pal2nal_bin = args.pal2nalbin
    pal2nal_options = args.pal2naloptions
    aln_options = args.alnoptions
    verbose = args.verbose
    run_codeml = args.codeml
    overwrite = args.overwrite

    print()
    
    topdir = os.getcwd() # working directory above all the output directories

    # take care of output directory

    if not os.path.exists(outdir_path):
        print(f"The specified output directory is created at: {outdir_path}")
        os.makedirs(outdir_path)
    else:
        print(f"The output directory {outdir_path} already exists, therefore existing output files are potentially overwritten")


    print(f"=========================== {outdir_path} ===========================")
    print()

    
    ############################
    ### make multifasta file ###
    ############################

    # check if the cds input is a directory (contains cds fasta complete for all species of interest)
    # or a file (cds multifasta directly corresponding to the proteinfasta orthogroup input file)

    if os.path.isdir(cds_path):
        if verbose:
            print(f"The path '{cds_path}' is a directory, \nit is supposed to contain multifasta files with all cds for the species included in the input proteinfasta.\nThe following files are in the directory:")
        # list and print files in directory
        files = [cds_path+f for f in os.listdir(cds_path) if os.path.isfile(os.path.join(cds_path, f))]
        if verbose:
            for file in files:
                print("\t"+file)


        ## make fasta of coding sequences that match the proteinfasta headers

        nucleotides_filename_unmodified = outdir_path+proteins_filename.split("/")[-1]+"_extracted_cds_unedited_header.fna"
        nucleotides_filename = outdir_path+proteins_filename.split("/")[-1]+"_extracted_cds.fna"

        # check if cds fasta already exists from a previous run, if so, skip
        if not os.path.exists(nucleotides_filename) or overwrite:

            nucleotide_fasta = make_cds_fasta(proteinfasta=proteins_filename, cds_list=files, verbose=verbose)

            with open(nucleotides_filename_unmodified, "w") as output_handle:
                SeqIO.write(nucleotide_fasta, output_handle, "fasta")
                print(f'Coding-sequences fasta file generated: {nucleotides_filename_unmodified}')
            with open(nucleotides_filename_unmodified, "r") as nuc_fasta_unmodded, open(nucleotides_filename, "w") as nuc_fasta:
                lines = nuc_fasta_unmodded.readlines()
                for line in lines:
                    if ">" in line:
                        line = line.split()[0]+"_1\n"
                    nuc_fasta.write(line)
                print(f"modified fasta headers, new outfile here: {nucleotides_filename}")

        else:
            print(f'\n{nucleotides_filename} already exists, will continue with pre-existing version')

    elif os.path.isfile(cds_path):
        print(f"The path '{cds_path}' is a file. It is assumed that it is a cds file matching {proteins_filename}")
        nucleotides_filename = cds_path
    if verbose:
        print()


    
    ###########################################
    ### do the alignment with clustal-omega ###
    ###########################################

    clustal_outfile = f"{outdir_path}orthogroup.prot_aln.fasta"

    # check if an alignment file exists from a previous run
    if not os.path.exists(clustal_outfile) or overwrite:
        
        if verbose:
            print("================ starting clustal-OMEGA:\n")
            if overwrite:
                print("overwrite mode enabled")
        


        clustal_omega_command = f"{clustal_bin} {aln_options} -i {proteins_filename} -o {clustal_outfile}"
        if overwrite:
            clustal_omega_command = f"{clustal_bin} {aln_options} -i {proteins_filename} -o {clustal_outfile} --force"

        start_time = time.time()
        print("command: "+clustal_omega_command)
        end_time = time.time()
        if verbose:
            passed_time = end_time - start_time
            if verbose:
                print(f"making the alignment took {passed_time:.2f} seconds, or {passed_time/60.0:.2f} minutes")
                
        result = subprocess.run(clustal_omega_command, shell = True, capture_output=True, text=True)
        # Check if the command was successful
        if result.returncode == 0 and verbose:
            print("clustal-OMEGA ran successfully.")
            print(result.stdout)
        else:
            print("clustal-OMEGA failed.")

    else:
        print(f"{clustal_outfile} exists already.")
    print()



    #####################################
    ############ run pal2nal ############
    #####################################

    # pal2nal_command = f"{pal2nal_bin} {outdir_path}orthogroup.prot_aln.fasta {nucleotides_filename} {pal2nal_options} >{outdir_path}orthogroup.pal2nal.paml"
    pal2nal_command = f"{pal2nal_bin} {outdir_path}orthogroup.prot_aln.fasta {nucleotides_filename} {pal2nal_options} > {outdir_path}orthogroup.pal2nal.paml"


    # /proj/naiss2023-6-65/Lila/beetle_genomes/pal2nal.v14/pal2nal.pl OG0006976_dNdS/orthogroup.prot_aln.fasta OG0006976_dNdS/OG0006976.fa_extracted_cds.fna > OG0006976_dNdS/orthogroup.pal2nal.paml
    if verbose:
        print("================ starting pal2nal\n")
    print("command: "+pal2nal_command)
    result = subprocess.run(pal2nal_command, shell = True, capture_output=True, text=True)
    # Check if the command was successful
    if result.returncode == 0 and verbose:
        print("pal2nal ran successfully.")
        print(result.stdout)
    else:
        print("pal2nal failed.")
        print(result.stderr)


    # Read the Clustal file
    alignment = AlignIO.read(f"{outdir_path}orthogroup.pal2nal.paml", "clustal")

    # Write the alignment in PHYLIP format
    # for details about sequential and interleaved phylip formats, see
    # paml documentation p. 11
    AlignIO.write(alignment, f"{outdir_path}orthogroup.pal2nal.paml", "phylip-sequential")

    # adjust spacing 
    adjust_phylip_spacing(f"{outdir_path}orthogroup.pal2nal.paml", f"{outdir_path}orthogroup.pal2nal.paml")

    if verbose:
        print(f"done, adjusted spacing in {outdir_path}orthogroup.pal2nal.paml")

    print()


    

    ###########################################
    ############# run PAML (yn00) #############
    ###########################################

    # in preparation to run paml, create a symlink of the treefile
    # parse treefile name from orthogroup file

    if not run_codeml: #if --codeml is not specified, run yn00 by default

        if verbose:
            print("================ set up and run paml (yn00)\n")
        
        treefile_name = proteins_filename.split("/")[:-2]
        OG_id = proteins_filename.split("/")[-1].split(".fa")[0]
        treefile_name = "/".join(treefile_name)+"/Gene_Trees/"+OG_id+"_tree.txt"

        if not os.path.exists(outdir_path+OG_id+"_tree.txt"):
            os.symlink(treefile_name, outdir_path+OG_id+"_tree.txt")
            if verbose:
                print(f"ln -s {treefile_name} {outdir_path}{OG_id}_tree.txt")
                print()


        # copy the yn00 config file 

        yn00_config_source = "/sw/bioinfo/paml/4.10.7/rackham/examples/yn00.ctl"
        yn00_config = f"{outdir_path}yn00.ctl"
        copy_command = f"cp {yn00_config_source} {yn00_config}"
        
        os.system(copy_command)
        if verbose:
            print(copy_command)
        

        ## modify the config file
        # The files are all in the same output folder as the config which is also used in the rest of this, 
        # therefore I will not use absolute filepaths

        yn00_settings_dict = {"seqfile" : "orthogroup.pal2nal.paml", # "orthogroup.pal2nal.phy",
                            "outfile" : "yn00.out"}

        if verbose:
            print()
            print("setting up paml config file with the following parameters:")
            # print(paml_settings_dict)

        modified_lines = []
        with open(yn00_config, "r") as config:
            lines = config.readlines()
            for line in lines: # go through all lines
                for key, value in yn00_settings_dict.items():
                    if key+" = " in line: # check if to-modify variable is in line
                        line = key+" = "+value+"\n" # make new line and overwrite the old one
                        if verbose:
                            print("\t"+line.split("\n")[0]) # remove the newline character for printing so it looks nicer
                modified_lines.append(line)
        with open(yn00_config, "w") as yn00:
            yn00.writelines(modified_lines)

        if verbose:
            print(f"done modifying {yn00_config}")
            print()

        ## set up paml run
        os.chdir(outdir_path) 
        wdir = os.getcwd()
        # run paml from the output directory, since the files referenced in yn00.ctl don't have absolut paths and are just filenames
        paml_command = "yn00 > yn00.log"
        if verbose:
            print("running yn00 from this directory: ")
            print(wdir)
            print(f"command: {paml_command}")

        # run paml and catch errors in case it goes wrong
        try:
            os.system(paml_command)
        except Exception as e:
            print(f"An error occurred while running yn00: {e}")

        print(f"\ndone with yn00, outfile: {wdir}/yn00.out")
        
    

    ### calculate pairwise dNdS from 2YN.dN and 2YN.dS
    # stay in the working directory for the orthogroup

    dN_filepath = "2YN.dN"
    dS_filepath = "2YN.dS"
    dNdS_filepath = "2YN.dNdS"



    if is_file_non_empty(dN_filepath) and is_file_non_empty(dS_filepath):
        if verbose:
            print(f"\n================ calcualte dN/dS ratio:")

        calculate_dNdS(dN_filepath, dS_filepath, dNdS_filepath)


    else: # if the 2YN files are empty/nonexistent, either because it didn't work or because --codeml was specified and it wasn't run

    ###########################################
    ############ run PAML (codeml) ############
    ###########################################


        print(f"\n{dN_filepath} or {dS_filepath} are empty, pairwise dN/dS could not be calculated, try to run codeml instead")
        print(f"\n================ run codeml")


        ## modify the newick tree to work with codeml

        with open(f"{OG_id}_tree.txt", 'r') as f, open(f"{OG_id}_tree_modified.txt", 'w') as o:
            if verbose:
                print(f"\nmodify the newick tree {OG_id}_tree.txt so that each leaf consists only of a 10 character string")
            newick_tree = f.read()
            modified_tree, num_species = truncate_leaf_names(newick_tree)
            o.write(f"\t{num_species} 1\n") # the numbers are first the number of species and then the number of trees
            o.write(modified_tree)
            
        if verbose:
            print(f"Modified tree saved to {OG_id}_tree_modified.txt\n")



        ## try to run codeml properly with the tree.

        #   from the paml documentation in the yn00 section p. 41:
        #       " We recommend that you use the ML method (runmode= 2, CodonFreq = 2 in codeml.ctl)
        #         as much as possible even for pairwise sequence comparison. "
        #   since we have a tree, I will still use runmode 0, since 2 is automatic (and does not require a tree)

        codeml_settings_dict = {"seqfile" : "orthogroup.pal2nal.paml", 
                        "treefile" : f"{OG_id}_tree_modified.txt",  ## TODO the treefile has one more iteration of the species name than the seqfile? not sure if that's a problem, it still runs but maybe it does some stuff?
                        "outfile" : "codeml.out", 
                        "model" : args.pamlmodel, # default paml model is 1
                        "verbose" : "1",
                        "seqtype" : "1",
                        #"runmode" : "2", # 2 is an automatic run mode, the default is 0 which is a user generated tree
                        "CodonFreq" : "2" 
                        } 
        

        os.chdir(topdir)
        # copy the codeml config file into the folder
        codeml_config_source = "/sw/bioinfo/paml/4.10.7/rackham/examples/codeml.ctl"
        codeml_config = f"{outdir_path}codeml.ctl"
        copy_command = f"cp {codeml_config_source} {codeml_config}"

        os.system(copy_command)
        if verbose:
            print(f"get config file: {copy_command}\nmodify config file:")
        

        ## modify the codeml config file:

        modified_lines = []        
        with open(codeml_config, "r") as codeml:
            lines = codeml.readlines()
            for line in lines: # go through all lines
                for key, value in codeml_settings_dict.items():
                    if key+" = " in line: # check if to-modify variable is in line
                    #if key in line: # check if to-modify variable is in line
                        line = key+" = "+value+"\n" # make new line and overwrite the old one
                        if verbose:
                            print("\t"+line.split("\n")[0]) # remove the newline character for printing so it looks nicer
                modified_lines.append(line)
        with open(codeml_config, "w") as yn00:
            yn00.writelines(modified_lines)

        if verbose:
            print(f"done modifying {codeml_config}")
            print()

        os.chdir(outdir_path)
        codeml_command = "codeml > codeml.log"
        if verbose:
            print(f"running: {codeml_command}")
        
        start_time = time.time()
        os.system(codeml_command) ## this does not run on the login node on uppmax! Nothing happens, you have to run it as sbatch even for testing
        end_time = time.time()

        if verbose:
            print("done with codeml")
            passed_time = end_time - start_time
            if verbose:
                print(f"codeml took {passed_time:.2f} seconds, or {passed_time/60.0:.2f} minutes")


        #### done with codeml, calculate dNdS based on that:

        dN_filepath = "2NG.dN"
        dS_filepath = "2NG.dS"
        dNdS_filepath = "2NG.dNdS"

        
        if is_file_non_empty(dN_filepath) and is_file_non_empty(dS_filepath):
            if verbose:
                print(f"\n================ calcualte dN/dS ratio:")

            calculate_dNdS(dN_filepath, dS_filepath, dNdS_filepath)
        
    os.chdir(topdir)


